name: Close issues with no tasks and a specific label

on:
  schedule:
    - cron: '0 0 * * 0'  # Runs every Sunday at midnight

  repository_dispatch:
    types: close-issues-ocwm

jobs:
  close-issues:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Set up Node 18 and Install dependencies
      uses: actions/setup-node@v2
      with:
        node-version: 18
        cache: 'npm'
      run: |
        npm install @octokit/core node-fetch

    - name: Close issues
      uses: actions/github-script@v6
      env:
        MY_TOKEN: ${{ secrets.AUTH_TOKEN }}
        MY_LABEL: ${{ vars.OCWM_LABEL }}
        OWNER: ${{ vars.ORGANISATION }}
        REPO_NAMES: ${{ vars.REPOSITORIES }}
      with:
        script: |
          const { Octokit } = require('@octokit/core');
          const fetch = require('node-fetch');

          const customFetch = async (url, options) => {
            const res = await fetch(url, {
              ...options,
              headers: {
                ...options.headers,
                authorization: `token ${process.env.MY_TOKEN}`,
              },
            });

            if (!res.ok) {
              throw new Error(`Request failed with status: ${res.status}`);
            }

            return res;
          };

          const mygithub = new Octokit({
            request: {
              fetch: customFetch,
            },
          });

          const label = process.env.MY_LABEL;

          const sevenDaysAgo = new Date();
          sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
          const dateString = sevenDaysAgo.toISOString().split('T')[0];

          const pattern = `label:"${label}" is:open created:<${dateString} repo:${process.env.REPO_NAMES} org:${process.env.OWNER}`;

          try {
            const response = await mygithub.request('GET /search/issues', {
              q: pattern,
              per_page: 100,
            });

            const issues = response.data.items;
            console.log(`Number of issues found: ${issues.length}`);

            const closeIssues = async (issues) => {
              for (const issue of issues) {
                console.log('Issue:' + JSON.stringify(issue));
                const repo = issue.repository_url.split('/').slice(-1)[0];
                const issue_number = issue.number;

                console.log('Repo:' + repo);
                const taskListRegex = /^\s*- \[[\sX]\]\s+/gm;
                const incompleteTaskRegex = /-\s+\[[ ]\]\s+.+/g;
                const hasTasks = taskListRegex.test(issue.body);
                const hasIncompleteTasks = incompleteTaskRegex.test(issue.body);

                if (!hasTasks || !hasIncompleteTasks) {
                  console.log(`Closing issue #${issue.number}`);
                  console.log(`POST /repos/${process.env.OWNER}/${repo}/issues/${issue_number}/comments`);
                  console.log(`PATCH /repos/${process.env.OWNER}/${repo}/issues/${issue_number}`);

                  await mygithub.request(`POST /repos/${process.env.OWNER}/${repo}/issues/${issue_number}/comments`, {
                    body: 'Closing this issue as all tasks are completed. Thanks for your contributions!',
                  });
                  await mygithub.request(`PATCH /repos/${process.env.OWNER}/${repo}/issues/${issue_number}`, {
                    state: 'closed',
                  });
                }
              }
            }
            await closeIssues(issues);
          } catch (error) {
            console.error('Error occurred:', error.message);
            process.exit(1);
          }
